Sauf mentions contraire, L'écriture conditionnelle est possible pour tous les Types de Requête suivants, ils auront alors un but conditionnel (voir "requêtes conditionnelles").

////// NAME //////


Le Type de Requête NAME permet de renommer un objet.
Attention ! Veuillez noter qu'il s'agit en quelque sorte d'une ID, il faut éviter d'utiliser plusieurs fois le même nom (en particulier pour les objets "vivants").
Note : lorsqu'un objet est "vivant", son visuel est automatiquement défini en fonction de son nom parmi les dossiers dans "textures/characters".
Note : il est tout à fait possible (et pratique) d'utiliser NAME de façon classique et conditionnelle afin d'imiter le comportement du Type de Requête MEMORY (voir "requêtes memory.txt).

exemple :
TIME -> 0 = NAME -> BOB
TIME -> 0 = GOTO -> NAME:BOB

Lorsque la Condition sera vérifiée, l'objet sera renommé Bob.

Cette Requête est très utile juste après la génération d'une map afin d'établir le nom d'un personnage (et ainsi d'afficher les bonnes textures).
Note : le nom générique OBJECT (qu'on trouvera souvent dans les fichiers de dialogue) fait référence à l'objet Piranha en cours. Le nom PLAYER est également possible pour faire référence au joueur.


////// FACING //////


Le Type de Requête FACING permet de changer l'orientation d'un objet.

exemple :
TIME -> 0 = FACING -> RIGHT
TIME -> 0 = GOTO -> FACING:RIGHT

Lorsque la Condition sera vérifiée, l'objet regardera à droite.

Il est tout à fait possible, au lieu d'écrire une direction, d'écrire le nom d'un autre objet, pour que l'objet se tourne vers direction.
ex : 
TALKED -> COMPUTER = FACING -> BOB
À la fin du dialogue "COMPUTER", l'objet se tournera vers BOB.

Attention ! Lorsqu'un nom est utilisé à la place d'une direction, un PathFinder est déclenché. Si un mur, une porte fermée, etc. fait obstacle, l'objet ne trouvera pas de chemin et ne changera donc pas son facing.
Attention ! Il est facile de se tromper : c'est seulement l'orientation de l'objet dans lequel est écrite cette Instruction qui change ! Si on veut changer le facing du player ou d'un npc, il faut écrire cette Instruction dans LEURS fichiers.


////// BLOCKING_PATH //////


Le Type de Requête BLOCKING_PATH permet de changer la propriété "bloquante" d'un objet.
Note : changer cette propriété change également les chemins valides du PathFinder.

exemple :
TIME -> 0 = BLOCKIN_PATH -> FALSE
TIME -> 0 = GOTO -> BLOCKIN_PATH:FALSE

Lorsque la Condition sera vérifiée, l'objet sera franchissable.

Note : par défaut, les objets Piranha sont bloquants.


////// BLOCKING_SIGHT //////


Le Type de Requête BLOCKING_SIGHT permet de changer la propriété "opaque" d'un objet.
Son utilité est très limitée, elle peut cependant s'avérer utile dans certaines situations, comme en utilisant le Type de Requête SEE par exemple (voir "requêtes conditionnelles").

Son écriture fonctionne exactement de la même manière que pour le Type de Requête BLOCKING_PATH.
Note : par défaut, les objets Piranha sont "non opaques". Dis autrement, par défaut, on voit au travers.


////// HITBOX //////


Le Type de Requête HITBOX permet de changer les dimensions de la hitbox d'un objet. L'intérêt est de rendre "propre" le chemin que peut emprunter le Joueur.
ATTENTION : changer les dimensions de la hitbox n'influence aucun autre facteur : ni les chemins valides du PathFinder (même avec une hibox réduit à 0), ni la position officielle de l'objet, ni la règle qui défini si un objet est "à portée", ni son visuel, etc. Il est donc fortement déconseillé d'utiliser cette propriété pour créer des objets "à deux cases".
Note : L'écriture conditionnelle n'est possible pour ce Type de Requête.

Ce Type de Requête requiert 4 Cibles : une position horizontale initiale (x), verticale (y), une largeur (width), et une hauteur (height).
L'échelle est de 16 pixels pour une taille de 1 case.

exemple :
TIME -> 0 = HITBOX -> 0, 0, 8, 16

Lorsque la Condition sera vérifiée, l'objet aura une hitbox par rapport à l'objet défini comme suit : x=0, y=0, largeur=8, hauteur=16.
Voici un petit schéma illustratif. À gauche, la hitbox d'origine. À droite, la nouvelle hitbox de l'objet :

XX	XO
XX	XO

Les 4 lettres représentent une case en tout. Les X représente un obstacle infranchissable. Les O représentent une position autorisée pour le Joueur.
Note : il est théoriquement possible de dépasser la taille d'origine d'un objet, et même d'entrer des valeurs négatives ! Tant que vous gardez à l'esprit que seule les dimensions de la hitbox change, cette pratique n'est pas déconseillée.
Note : afin de "voir" vos hitbox, vous pouvez utiliser le debugMode "illumitati" (ressources/userdata/debugmod.txt)


////// INVULNERABLE //////


Le Type de Requête INVULNERABLE permet de changer la propriété "vulnérable" de l'objet courant.
Note : les objets "obj" ne peuvent pas devenir vulnérable, cette propriété ne concerne que les objets vivants ("npc", "player", etc.).

exemple :
TIME -> 0 = INVULNERABLE -> TRUE
TIME -> 0 = GOTO -> INVULNERABLE:TRUE

Lorsque la Condition sera vérifiée, l'objet deviendra invulnérable.

Note : par défaut, les objets vivant sont vulnérables.
Note : lorsque le joueur est invulnérable, ses PV ne sont plus affichés.


////// CONDITION //////


Le Type de Requête CONDITION n'a rien à voir avec une requête Conditionnelle (même si cette dernière reste possible) ! Elle permet de changer la "condition" de l'objet courant.

exemple :
TIME -> 0 = CONDITION -> GOOD
TIME -> 0 = GOTO -> CONDITION:GOOD

Lorsque la Condition sera vérifiée, l'objet adoptera la condition par défaut.

La condition permet d'altérer à la fois le visuel d'un personnage et son comportement. Voici les conditions existentes :
- GOOD, condition par défaut
- GLASS, le personnage tient un verre d'eau
- SICK, le personnage a l'air malade
- BATH, seul la tête du personnage est visible. Il a l'air de dormir et ne peut plus bouger (mais peut toujours interagir !)
- BED, le personnage a l'air de dormir, et ne peut plus bouger (mais peut toujours interagir !)
- CRY, le personnage a l'air de pleurer, et ne peut plus bouger (mais peut toujours interagir !)
- RELAX, le personnage a l'air allongé, et ne peut plus bouger (mais peut toujours interagir !)
- SIT, le personnage a l'air sur des toilettes, et ne peut plus bouger (mais peut toujours interagir !)
- KO, le personnage a l'air allongé et ne peut plus rien faire.


////// PLAYER_AVOIDER_TYPE //////


Attention ! Cette requête N'EST PAS un Type de Requête player (voir "requêtes player.txt"). Ces dernières ont le mot "PLAYER" en fin et non en début de nom.
Le Type de Requête PLAYER_AVOIDER_TYPE permet de changer la "règle d'évitement" d'un personnage à l'égare du joueur. L'écriture conditionnelle est possible.

exemple :
TIME -> 0 = PLAYER_AVOIDER_TYPE -> AROUND
TIME -> 0 = GOTO -> PLAYER_AVOIDER_TYPE:AROUND

Lorsque la Condition sera vérifiée, l'objet adoptera le type d'évitement AROUND (qui est celui défini par défaut pour les personnages).


Les types d'évitement sont au nombre de 6 et voici leurs fonctionnements :
- AROUND est le seul type d'évitement avec CUTSCENE où le joueur est compté comme un obstacle pour le pathfinder : le personnage va donc tenter de le contourner. S'il ne peut pas, il se rapprochera à distance suffisante et attendra que ce dernier se décale. Dans le cas où le personnage est "en plein mouvement entre deux cases" et qu'une collision survient avec le joueur, il fera "glisser" ce dernier afin de finir son mouvement jusqu'à une case entière.
- CUTSCENE a le même fonctionnement que AROUND à ceci près que AROUND semble plus "naturelle" lors des phases de gameplay. Avec AROUND, les personnages ne tentent pas de se déplacer si le joueur est trop près, car ce dernier est la plupart du temps en mouvement et qu'un risque de collision est fort : ils "attendent d'avoir plus de place". Lors des cinématiques, le joueur est la plupart du temps statique et proche des personnages : ces derniers ont plus de liberté de mouvement et ne devraient pas attendre que le joueur soit loin pour se déplacer.
Attention ! le player avoider ne change pas "tout seul" lors des cinématiques : il reste le même que celui qu'on a défini en dernier. Même chose à la sortie de ces dernières.

Dans tous les cas suivants, le pathfinder va ignorer l'existence du joueur dans le calcul du trajet. C'est le type de réaction face à une collision avec le joueur qui change :
- THROUGH, le personnage va ignorer purement et simplement le joueur : il lui passera au travers ! (cela peut être utile lors de cinématiques).
- STOP, le personnage va s'arrêter net et attendre que le joueur s'en aille (en suivant du regard ce dernier) avant de reprendre son chemin. 
- PUSH, le personnage va pousser le joueur en face de lui. Aucune pause n'est marquée.
- PUSH_DIRECTION (il faut remplacer "DIRECTION" par "LEFT", "RIGHT", "UP" ou "DOWN"), le personnage va pousser le joueur dans la direction indiquée. Aucune pause n'est marquée.
- PUSH_HURT, le personnage va pousser le joueur en face de lui et lui retirer de la vie. Le personnage marquera une "courte pause" après cette action (en se figeant sur place).

Note: si le PLAYER_AVOIDER_TYPE est défini par défaut sur AROUND, il ne faut pas hésiter à le mettre sur STOP dans les espaces étroits afin de ne pas avoir des lags à cause du PathFinder qui ne trouve pas de chemin valide.


Il existe tout un autre panel de Type de Requête state, pour les connaître, voir le fichier "requêtes player.txt"