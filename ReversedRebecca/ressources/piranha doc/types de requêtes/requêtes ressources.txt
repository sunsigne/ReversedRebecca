Les Types de requêtes suivants ont pour Cibles le nom d'un fichier dans le dossier "ressources" du jeu, vous pouvez donc créer vos propres Cibles !

Note : d'un point de vue technique, le Type de Requête NAME est partiellement de type ressources dans la mesure où sa cible sert d'ID, mais charge également la texture d'un personnage en cherchant parmi les fichiers dans le dossier "ressources/textures/characters/(nom de la cible)".


////// EXPRESSION //////

Le Type de Requête EXPRESSION permet d'afficher une bulle expressive au-dessus d'un objet.
La Cible de ce Type de Requête cherche le fichier correspondant dans le dossier "ressources/textures/other".

exemple :
TIME -> 0 = EXPRESSION -> SUSPENSION
TIME -> 0 = GOTO -> EXPRESSION:SUSPENSION

Lorsque la Condition sera vérifiée, une bulle avec des points de suspensions apparaitra au-dessus de l'objet.

Ces bulles disparaissent en peu de temps. Leur but est avant tout "d'habiller" une cinématique.

Officiellement, il en existe 2 :
- SUSPENSION, qui affiche des points de suspensions.
- EXLAMATION, qui affiche un point d'exclamation.

Note : l'expression "exclamation" a une animation supplémentaire par rapport aux autres, semblable à un "petit saut".


////// MUSIC //////

Le Type de Requête MUSIC permet d'arrêter la musique qui se joue actuellement (il peut y en avoir aucune) et de lancer la musique en cible.
La Cible de ce Type de Requête cherche le fichier correspondant dans le dossier "ressources/audio/music".

Note : pour arrêter une musique sans en lancer une autre, il suffit d'écrire "NULL" pour cible.
Note : si la musique cible est déjà celle qui est en train d'être jouée, au lieu de la relancer, cette requête n'aura aucun effet.

exemple :
TIME -> 0 = MUSIC -> EXEMPLE_MUSIC
TIME -> 0 = GOTO -> MUSIC:EXEMPLE_MUSIC

Lorsque la Condition sera vérifiée, la musique "exemple_music.wav" sera jouée.

Note : Cette requête change progressivement la musique, aussi bien en arrivée qu'en sortie (càd vers le silence si MUSIC:NULL est appelé). Si l'on veut la changer "soudainement", il faut utiliser le Type de Requête MUSIC_WITHOUT_TRANSITION.

Attention ! Si une instruction contenant ce type de requête est appelé pendant l'écran titre (par exemple, pour les niveaux se passant chez Rebecca), elle sera "enregistrée"* et ne s'effectuera que lorsque le joueur lancera le niveau : la musique durant l'écran titre reste toujours la même.
*l'enregistrement s'effectue via une Instruction cachée dont le Type de Requête est WAITFOR, il faut donc faire attention à ne pas écraser par accident un WAITFOR précédent (voir "requêtes autres"). Il est d'ailleurs conseillé d'effectuer une telle Instruction dans le fichier SETUP.


////// MUSIC_WITHOUT_TRANSITION //////

Le Type de Requête MUSIC_WITHOUT_TRANSITION a exactement le même effet et est soumis aux mêmes règles que le permet Type de Requête MUSIC.
La seule différence avec cette dernière est que MUSIC_WITHOUT_TRANSITION change la musique "d'un seul coup". (utile lors des changements soudain d'ambience).


////// SOUND //////

Le Type de Requête SOUND permet de jouer un son.
La Cible de ce Type de Requête cherche le fichier correspondant dans le dossier "ressources/audio/sound".

exemple :
TIME -> 0 = SOUND -> EXEMPLE_SOUND
TIME -> 0 = GOTO -> SOUND:EXEMPLE_SOUND

Lorsque la Condition sera vérifiée, le son "exemple_sound.wav" sera joué.

Note : Le Type de Requête SOUND est ignoré lorsque le Type de Condition est SAVED, ce qui facilite grandement la tâche !


////// TALK //////

Le Type de Requête TALK permet de lancer un dialogue.
La Cible de ce Type de Requête cherche le fichier correspondant dans le dossier "ressources/texts/(la langue actuelle)/maps/(la map actuelle)".

exemple :
TIME -> 0 = TALK -> PEEBOY_PEE_ITS_PANTS
TIME -> 0 = GOTO -> TALK:PEEBOY_PEE_ITS_PANTS

Lorsque la Condition sera vérifiée, le dialogue "peeboy_pee_its_pants.csv" sera lancé.

L'écriture des fichiers dialogues est un peu particulière, expliquons l'exemple suivant :

object = player = urge_sad = C'est#trop#tard…
player = object = sad = Ha…
object = player = urge_happy = T'inquiète#pas.@Je#n'ai#plus#qu'à#aller#pleurer#dans#un#coin…

La première partie définie la personne qui parle à partir de son NAME, et affichera son visage dans la boite de dialogue. Le mot "objet" est autorisé pour pointer l'objet Piranha qui a lancé la requête de dialogue.
La seconde partie désigne la direction vers laquelle cette personne doit se tourner à partir d'une requête FACING, elle accepte donc les mêmes cibles que cette dernière, en plus du mot "objet".
Le troisième partie désigne l'expression que la personne qui parle doit adopter. Cette dernière est directement disponible dans le dossier de texture du personnage en question.
La quatrième partie est le dialogue qui doit s'afficher.

Les espaces permettent de gagner en lisibilité dans le code, mais ils sont ignorés par le programme ; c'est pourquoi des '#' sont introduits dans le texte et seront comptés comme des espaces à l'affichage.
De la même façon, le caractère "saut de ligne" dans le dialogue est le symbole "@". Il peut y en avoir aucun, mais il ne doit pas y en avoir plus d'un par ligne de texte !


////// DEED //////

Le Type de Requête DEED permet de définir ce qui est une bonne ou une mauvaise action.
Lorsqu'un niveau est terminé, un écran affiche un récapitulatif pour le joueur. Sur cet écran est mentionné la bonne et la mauvaise action ayant le plus grand "poids"
Note : n'oubliez pas que les bonnes et les mauvaises actions influent sur la fin obtenue par le joueur ; ne négligez pas cet aspect.

exemple :
$ -> DEED_OFFER_PANCAKES = DEED -> GOOD, OFFER_PANCAKES

Lorsque la Condition sera vérifiée, une action sera enregistrée comme bonne. Son nom et son "poids" seront déterminés par les valeurs trouvées dans le dossier mentionné ci-dessous :
la seconde cible cherche la valeur correspondante dans le dossier "ressources/texts/(la langue actuelle)/maps/(la map actuelle)/deeds.csv".
Note : le "poids" détermine le nom de l'action à afficher sur l'écran de fin de niveau : le poids le plus fort l'emporte.


////// GOOD_DEED //////

Est un raccourci direct de DEED, mais dont la cible GOOD est incluse dans le Type de Requête.
La seconde cible devenant unitaire, l'écriture compacte devient alors possible.

////// BAD_DEED //////

Exactement le même principe qu'avec GOOD_DEED.
