////// CAMERA //////

Le Type de Requête CAMERA permet de déterminer le type de Caméra ou son emplacement.

Exemple : 
TIME -> 0 = CAMERA -> 0-0
TIME -> 0 = GOTO -> CAMERA:0-0

Lorsque la Condition sera vérifiée, la Caméra se placera en x = 0 et y = 0.

Les Cibles suivantes permettent de modifier le comportement de la Caméra :
PLAYER : ordonne à la Caméra de suivre le joueur.
PLAYER_FLUID : ordonne à la Caméra de suivre le joueur. Au moment de son enclenchement, Celle-ci se "déplacera très rapidement" vers lui au lieu de se "téléporter" sur sa position.
FIX : ordonne à la caméra de cesser de suivre le joueur et rester "là où elle se trouve actuellement".

Note : le comportement par défaut de la Caméra au chargement d'une carte est de se placer en 0-0.


////// INTERRUPT_BOSS //////

Le Type de Requête INTERRUPT_BOSS permet de terminer l'action en cours de tous les Boss actuellement présents sur la même couche (voir "index") que l'objet lançant la Requête. Dit autrement, si un Boss est en train de se reposer, il retourne à l'attaque.

Exemple :
WONPUZZLE -> 6-0 = INTERRUPT_BOSS -> PROCESS

Note : ce Type de Requête est l'un des très rares dont la Cible n'est toute simplement pas lue ! Elle doit tout de même être écrite afin de respecter la syntaxe attendue. Par souci de clarté, il est conseillé d'écrire quelque chose comme : TRUE, PROCESS ou START.


////// DISPLAY //////

Le Type de Requête DISPLAY permet de déterminer l'emplacement visuel d'un objet selon les axes x et y. 
De la même façon que le Type de Requête HITBOX ne change QUE les dimensions de la hitbox d'un objet (voir "requêtes state"), DISPLAY ne change QUE le visuel de l'objet : aucune autre caractéristique n'est prise en compte.
Il est utilisé lorsqu'un personnage se trouve dans un lit, sur une chaise, etc.

Note : dans la mesure où seuls les objets Piranha "vivants" ont officiellement un visuel, le Type de Requête DISPLAY ne s'applique qu'à ces derniers.

L'échelle est de 16 pixels pour une case (voir le Type de requête HITBOX).

Exemple :
$ -> DISPLAY_SIT = DISPLAY -> 0, -1

Lorsque la Condition sera vérifiée, l'objet sera visuellement légèrement décalé vers le haut par rapport à sa position réelle.

Note : il est possible d'entrer des valeurs négatives pour ce Type de Requête.


////// HIGHLIGHT //////

Le Type de Requête HIGHLIGHT permet de déterminer l'emplacement visuel du détourage d'un objet interactif lorsque celui-ci peut être utilisé. 

L'échelle est de 1 pour une case.

Exemple :
$ -> HIGHLIGHT_INIT = HIGHLIGHT -> -1, -1, 2, 3

Lorsque la Condition sera vérifiée, le détourage de l'objet sera visuellement décalé comme suit : x=-1, y=-1, largeur=2, hauteur=3.

Note : il est possible d'entrer des valeurs négatives pour ce Type de Requête.


////// HIGHLIGHT_ABSOLUTE //////

Le Type de Requête HIGHLIGHT_ABSOLUTE a exactement le même effet et est soumis aux mêmes règles que le permet Type de Requête HIGHLIGHT.
La seule différence avec cette dernière est que HIGHLIGHT_ABSOLUTE ne se base pas sur un décalage relative "par rapport" à la position de l'objet sur la map, mais utilise les coordonnées de la carte directement.


////// HIGHLIGHT_REFRESH //////

Le Type de Requête HIGHLIGHT_REFRESH permet de réactualiser le visuel du détourage d'un objet à partir de son fichier de référence.
Pour changer ce fichier de référence, il suffit de le renomer (voir NAME dans "requêtes state").
Note : ce Type de Requête est l'un des très rares dont la Cible n'est toute simplement pas lue ! Elle doit tout de même être écrite pour respecter la syntaxe attendue.

Exemple :
$ -> HIGHLIGHT_INIT = HIGHLIGHT_REFRESH -> PROCESS
$ -> HIGHLIGHT_INIT = GOTO -> HIGHLIGHT_REFRESH:PROCESS

Lorsque la Condition sera vérifiée, le visuel du détourage de l'objet sera réactualisé à partir du fichier de référence "(nom de l'objet).png".

Note : par souci de clarté, il est conseillé d'écrire pour Cible : TRUE, PROCESS, START ou n'importe quoi de cohérent.


////// CUTSCENE //////

Le Type de Requête CUTSCENE permet de lancer ou d'arrêter une scène cinématique.
Note : il peut parfois être utile de vérifier si le Joueur respecte certaines conditions avant de lancer une cinématique (voir READY_PLAYER dans "requêtes conditionnelles").

exemple :
TIME -> 0 = CUTSCENE -> START
TIME -> 0 = GOTO -> CUTSCENE:START

Lorsque la Condition sera vérifiée, une scène cinématique sera lancée.

Les trois choses que font une scène cinématique sont :
- afficher des bandes noires en haut et en bas de l'écran.
- centrer le joueur sur la "case" où il est actuellement le plus.
- interdire à l'utilisateur de contrôler le joueur avec le clavier.

Le Type de Requête CUTSCENE accepte 3 cibles :
- START, pour lancer une scène cinématique.
- STOP, pour arrêter une scène cinématique.
- STOP_WITH_DELAY, pour arrêter une scène cinématique après un court délais (1 secondes). On ne sait jamais, ça peut servir ¯\_(ツ)_/¯

Attention ! Assurez-vous toujours qu'une cinématique ait une fin ! Sans quoi l'utilisateur ne pourra pas reprendre le contrôle du joueur.
Attention : à part la vitesse de base du joueur qui est modifiée, les mouvements durant les cutscene suivent les mêmes règles que hors de ces dernières. Si un personnage est bloqué, car le joueur est considéré comme étant "trop près", effectuez une requête PLAYER_AVOIDER_TYPE:CUTSCENE (voir "requêtes states").


L'écriture conditionnelle est possible, quoique légèrement différente de d'habitude.
Lorsque cette dernière est utilisée, elle vérifie toujours si une cinématique est en cours; peu importe la cible écrite.

ex : 
TIME -> 100 = GOTO -> TRY_ARRIVING
$ -> TRY_ARRIVING = CUTSCENE -> RUNNING ? WAITING_BEFORE_ARRIVING / ARRIVE_NOW
$ -> WAITING_BEFORE_ARRIVING = WAITFOR -> TIMER:1 ? TRY_ARRIVING

Lorsque la condition sera vérifiée, une nouvelle condition doit être vérifiée : une cinématique est-elle en cours ?
- si oui, effectuer l'action WAITING_BEFORE_ARRIVING (qui est une balise comme pour GOTO)
- si non, effectuer l'action ARRIVE_NOW (qui est une balise comme pour GOTO)
Note : dans notre exemple la 3ème Instruction forme une boucle avec la seconde, de cette façon l'action ARRIVE_NOW s'effectuera lorsque la cinématique est finie (puisque cette boucle-ci implique que la condition soit vérifiée chaque seconde jusqu'à ce qu'elle soit validée).

Rappel, le mot "RUNNING" n'est pas analysé ici. L'écriture conditionnelle du Type de Requête CUTSCENE vérifiera TOUJOURS si une cinématique est en cours ; peu importe le mot écrit. Il est bien sûr conseillé d'écrire "RUNNING" afin que la requête ait du sens à la lecture.


////// WAITFOR //////

Le Type de Requête WAITFOR est à la fois l'un des plus utiles et le plus compliqué à utiliser correctement !
L'écriture d'un WAITFOR, même si elle est différente, ressemble un peu à l'écriture Conditionnelle : il accepte une cible de "Condition", suivi d'une ou de plusieurs Cibles séparées par des virgules (comme pour GOTO), exécutée(s) lorsque la condition est vérifiée.
Note : s'il est autorisé d'écrire plusieurs Cibles "requêtes" dans un WAITFOR, il est recommandé de n'en écrire qu'une seule par soucis de lisibilité.

Attention ! Il ne peut y avoir qu'un seul waitfor actif en même temps par objet Piranha. En effet, le Type de Requête WAITFOR écrase les waitfor précédents ! Soyez donc précis lorsque vous voulez enchainer plusieurs actions : la seconde cible du waitfor est tout indiquée pour créer une balise GOTO qui exécutera votre action et lancera un autre waitfor.
Attention ! Plusieurs Types de Requête lance des Instructions "cachés" dont le Type de Requête est WAITFOR (cela est systématiquement précisé). Prenez bien garde en les utilisant à ne pas écraser le waitfor précédent.

exemple en situation :

TALKED -> PEEBOY_FIND_A_ROOM = GOTO -> WAITING_BEFORE_CONFESSING, CUTSCENE:START, MEMORY:TOO_LATE
$ -> WAITING_BEFORE_CONFESSING = WAITFOR -> TIMER:1 ? IS_ASHAMED
$ -> IS_ASHAMED = GOTO -> AVOID_LOOKING, EXPRESSION:SUSPENSION, WAITING_BEFORE_CONFESSING_AGAIN
$ -> AVOID_LOOKING = FACING -> DOWN ? FACING:LEFT / FACING:DOWN
$ -> WAITING_BEFORE_CONFESSING_AGAIN = WAITFOR -> TIMER:2 ? TALK:PEEBOY_PEE_ITS_PANTS
TALKED -> PEEBOY_PEE_ITS_PANTS = FACING -> DOWN ? CREATE_HORIZONTAL_PEE_PUDDLES / CREATE_VERTICAL_PEE_PUDDLES

L'exemple ici est une cinématique où PEEBOY confesse qu'il s'est accidentellement fait pipi dessus. Les WAITFOR ici permettent de marquer des temps de pause entre les dialogues afin de rendre la "confession" crédible. Voyez comme les 2 WAITFOR n'ont pas été créé en même temps dès le départ, c'est bien le premier qui créé le second dans sa cible.

Le Type de Requête WAITFOR accepte les "Conditions" suivantes :
- TIMER:X (remplacer "X" par un nombre), attend X secondes avant d'effectuer la requête.
- FACING:DIRECTION (remplacer "DIRECTION" par "LEFT", "RIGHT", "UP" ou "DOWN"), n'exécute la requête que lorsque l'objet appelant cette Instruction regarde dans la direction choisie.
- PLAYER_FUTHER_THAN:X (remplacer "X" par un nombre), n'exécute la requête que lorsque le joueur est plus loin que X cases.
- PLAYER_CLOSER_THAN:X, même principe qu'avec FUTHER, mais on mesure cette fois la proximité au lieu de l'éloignement.
- PLAYER_FACING:DIRECTION (remplacer "DIRECTION" par "LEFT", "RIGHT", "UP" ou "DOWN"), n'exécute la requête que lorsque le joueur regarde dans la direction choisie. (Note : il est possible de mettre un point d'exclamation "!" devant la direction pour obtenir l'inverse de la condition - càd toutes les directions sauf celle indiquée).

Note : dans la mesure où un WAITFOR écrase les waitfor précédents, si l'on a besoin d'annuler un waitfor existant, il suffit d'écrire la requête "WAITFOR -> TIMER:0 ? NULL".


Attention ! Aussitôt qu'est appelée une Instruction dont le Type de Requête est WAITFOR, l'objet est automatiquement "dé-stun"; et donc immobilisé pendant 1 frame. Il faut donc éviter d'appeler ce Type de Requête juste après avoir utilisé le Type de Requête PUSH par exemple (voir "requêtes move") qui serait instantanément annulé.

Pour le dire plus simplement, n'écrivez pas :
TIME -> 0 = GOTO -> PUSH:UP, WAITING_BEFORE_STUFF
$ -> WAITING_BEFORE_STUFF = WAITFOR -> TIMER:1 ? DO_STUFF

Écrivez à la place :
TIME -> 0 = GOTO -> WAITING_BEFORE_STUFF, PUSH:UP
$ -> WAITING_BEFORE_STUFF = WAITFOR -> TIMER:1 ? DO_STUFF


////// END_LVL //////

Le Type de Requête END_LVL permet de demander au programme de charger les nouveaux niveaux pour l'écran titre et pour le jeu en cours.
Attention ! Ce chargement s'effectuera différemment en fonction de la première Cible renseignée :

- NORMAL : afficher l'écran de fin de niveau
- QUIET : le joueur accèdera directement au niveau suivant
- START_GAME : le joueur est envoyé à l'écran titre du jeu
- END_GAME : le joueur est envoyé vers les crédits du jeu

Note : les demandes enregistrées par le Type de Requête SAVE (voir "requêtes memory.txt") sont traitées aussitôt le Type de Requête END_LVL appelé (avant toute opération).

exemple :
WONPUZZLE -> 6-0 = END_LVL -> NORMAL, REBECCAS_ROOM_1, LVL001

Lorsque le Puzzle en x=6 y=0 sera résolu, le niveau prendra fin et le lvl001 sera chargé. Parallèlement, l'écran titre affichera maintenant le niveau REBECCAS_ROOM_1. Sur l'écran de victoire, les données affichées dépendront du karma du joueur (voir requêtes ressources : "Type de Requête DEED") et des compteurs (voir requêtes ressources : "Type de Requête COUNTER").

Note : l'écran titre changeant est une mécanique très intéressante. Vous pouvez totalement l'ignorer, mais cela sera dommage de passer à côté de l'histoire qu'il peut raconter.
Note : dans le cas d'une première Cible "START_GAME", les Cibles suivantes ne sont tout simplement pas lues ! Elles doivent tout de même être écrites pour respecter la syntaxe attendue.