////// CAMERA //////


Le Type de Requête CAMERA permet de déterminer l'emplacement de la Caméra.

exemple :
TIME -> 0 = CAMERA -> 0-0
TIME -> 0 = GOTO -> CAMERA:0-0

Lorsque la Condition sera vérifiée, la Caméra se placera en x=0 y=0.

Note : il est tout à fait autorisé d'entrer "PLAYER" comme Cible à la place de coordonnées afin de demander à la Caméra suivre le joueur.
Note : le comportement par défaut de la Caméra n'est pas de suivre le joueur, mais de se placer en 0-0. Il faudra donc configurer le fichier SET-UP à chaque fois.


////// DISPLAY //////


Une fois n'est pas coutûme, le Type de Requête DISPLAY peut avoir 2 comportement différents, selon qu'il n'a qu'une seul ou deux cibles.
À cause de son caractère particulier, l'écriture compacte de DISPLAY est interdite ; même lorsqu'il n'a qu'une seule cible.

Note : il va sans dire que dans la mesure où seuls les objets Piranha "vivants" ont un visuel, le Type de Requête DISPLAY ne s'applique qu'à ces derniers.


////// DISPLAY DEUX CIBLES //////


Ce Type de Requête DISPLAY permet de déterminer l'emplacement visuel d'un objet selon les axes x et y.
De la même façon que le Type de Requête HITBOX ne changeait QUE les dimensions de la hitbox d'un objet (voir requêtes state.txt), ce DISPLAY ne change QUE le visuel d'un objet et aucune autre caractéristique.

Ce Type de Requête requiert 2 Cibles : une position horizontale (x), et une verticale (y).
L'échelle est de 16 pixels pour une taille de 1 case.

exemple :
TIME -> 0 = DISPLAY -> 0, 8

Lorsque la Condition sera vérifiée, l'objet sera visuellement la moitié d'une case plus bas que sa position réelle.
Note : ce Type de Requête est pratique lorsqu'un personnage se trouve dans une situation particulaire comme dans un lit, sur une chaise, etc.
Note : il est possible d'entrer des valeurs négatives.


////// DISPLAY UNE CIBLE //////


Le Type de Requête DISPLAY permet de déterminer l'emplacement visuel d'un objet "selon l'axe Z".
ATTENTION : Ce Type de Requête DISPLAY influence l'index de l'objet (voir index.txt). Ce DISPLAY ne "change pas" le visuel d'un objet, mais change son emplacement dans le code même du jeu ! Ainsi, si vous utilisez une requête DISPLAY:FRONT, l'objet adoptera automatiquement l'index 1. À l'inverse, DISPLAY:BACK lui donnera un index élevé.

exemple :
TIME -> 0 = DISPLAY -> FRONT

Lorsque la Condition sera vérifiée, l'objet sera visuellement au-dessus des autres.
Note : lors que la génération d'une map vient de se terminer, les objets "vivants" ont une Instruction cachée se lançant automatiquement : TIME -> 0 = DISPLAY -> FRONT

Ce Type de Requête DISPLAY accepte les Cibles suivantes :
- FRONT : place l'objet "devant" les autres.
- BACK : place l'objet "derrière" les autres.


////// CUTSCENE //////


Le Type de Requête CUTSCENE permet de lancer ou d'arrêter une scène cinématique.

exemple :
TIME -> 0 = CUTSCENE -> START
TIME -> 0 = GOTO -> CUTSCENE:START

Lorsque la Condition sera vérifiée, une scène cinématique sera lancée.

Les deux "seules choses" que font une scène cinématique sont :
- d'afficher des bandes noires en haut et en bas de l'écran.
- d'interdire à l'utilisateur de contrôler le joueur avec le clavier.

Le Type de Requête CUTSCENE accepte 3 cibles :
- START, pour lancer une scène cinématique.
- STOP, pour arrêter une scène cinématique.
- STOP_WITH_DELAY, pour arrêter une scène cinématique après un court délais (1 secondes). On ne sait jamais, ça peut servir ¯\_(ツ)_/¯

Attention ! Assurez-vous toujours qu'une cinématique ait une fin ! Sans quoi l'utilisateur ne pourra pas reprendre le contrôle du joueur.


////// WAITFOR //////


Le Type de Requête WAITFOR est à la fois l'un des plus utiles et le plus compliqué à utiliser correctement !
L'écriture d'un WAITFOR, même si elle est différente, ressemble un peu à l'écriture Conditionnelle : il accepte une cible de "Condition", suivi d'une ou de plusieurs Cibles séparées par des virgules (comme pour GOTO), exécutée(s) lorsque la condition est vérifiée.
Note : s'il est autorisé d'écrire plusieurs Cibles "requêtes" dans un WAITFOR, il est recommandé de n'en écrire qu'une seule par soucis de lisibilité.
Attention ! Il ne peut y avoir qu'un seul waitfor actif en même temps par objet Piranha. En effet, le Type de Requête WAITFOR écrase les waitfor précédents ! Soyez donc précis lorsque vous voulez enchainer plusieurs actions : la seconde cible du waitfor est tout indiquée pour créer une balise GOTO qui exécutera votre action et lancera un autre waitfor.

exemple en situation :

TALKED -> PEEBOY_FIND_A_ROOM = GOTO -> WAITING_BEFORE_CONFESSING, CUTSCENE:START, MEMORY:TOO_LATE
$ -> WAITING_BEFORE_CONFESSING = WAITFOR -> TIMER:1 ? IS_ASHAMED
$ -> IS_ASHAMED = GOTO -> AVOID_LOOKING, EXPRESSION:SUSPENSION, WAITING_BEFORE_CONFESSING_AGAIN
$ -> AVOID_LOOKING = FACING -> DOWN ? FACING:LEFT / FACING:DOWN
$ -> WAITING_BEFORE_CONFESSING_AGAIN = WAITFOR -> TIMER:2 ? TALK:PEEBOY_PEE_ITS_PANTS
TALKED -> PEEBOY_PEE_ITS_PANTS = FACING -> DOWN ? CREATE_HORIZONTAL_PEE_PUDDLES / CREATE_VERTICAL_PEE_PUDDLES

L'exemple ici est une cinématique où PEEBOY confesse qu'il s'est accidentellement fait pipi dessus. Les WAITFOR ici permettent de marquer des temps de pause entre les dialogues afin de rendre la "confession" crédible. Voyez comme les 2 WAITFOR n'ont pas été créé en même temps dès le départ, c'est bien le premier qui créé le second dans sa cible.

Le Type de Requête WAITFOR accepte les "Conditions" suivantes :
- TIMER:X (remplacer "X" par un nombre), attend X secondes avant d'effectuer la requête.
- PLAYER_FUTHER_THAN:X (remplacer "X" par un nombre), n'exécute la requête que lorsque le joueur est plus loin que X cases.
- PLAYER_CLOSER_THAN:X, même principe qu'avec FUTHER, mais on mesure cette fois la proximité au lieu de l'éloignement.
- PLAYER_FACING:DIRECTION (remplacer "DIRECTION" par "LEFT", "RIGHT", "UP" ou "DOWN"), n'exécute la requête que lorsque le joueur regarde dans la direction choisie. (Note : il est possible de mettre un point d'exclamation "!" devant la direction pour obtenir l'inverse de la condition - càd toutes les directions sauf celle indiquée).

Note : dans la mesure où un WAITFOR écrase les waitfor précédents, si l'on a besoin d'annuler un waitfor existant, il suffit d'écrire la requête "WAITFOR -> TIMER:0, NULL".


////// END_LVL //////

Le Type de Requête END_LVL permet de demander au programme de charger les nouveaux niveaux pour l'écran titre et pour le jeu en cours.
Note : les demandes enregistrées par le Type de Requête SAVE (voir "requêtes memory.txt") sont traitées juste avant l'enregistrement des nouveaux niveaux.

exemple :
WONPUZZLE -> 6-0 = END_LVL -> REBECCAS_ROOM_1, LVL001

Lorsque le Puzzle en x=6 y=0 sera résolu, le niveau prendra fin et le lvl001 sera chargé. Parallèlement, l'écran titre affichera maintenant le niveau REBECCAS_ROOM_1.

Note : l'écran titre changeant est une mécanique très intéressante. Vous pouvez totalement l'ignorer, mais cela sera dommage de passer à côté de l'histoire qu'il peut raconter.
